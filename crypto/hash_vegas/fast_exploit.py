"""
Fast exploit - minimal output, maximum speed.
Purpose:
- Automate interaction with the Hash Vegas challenge service over TLS.
- Rapidly purchase lottery tickets until a winning voucher is obtained.
- When a SHA-1-backed voucher is encountered, perform a length extension attack
  to append '|1000000000' to the voucher payload, keeping the hash valid and
  overriding the parsed amount (rightmost token wins).
- Redeem the forged voucher and retrieve the flag.
"""

#!/usr/bin/env python3

import socket
import ssl
import re
import sys
from sha1_extend import sha1_extend

HOST = 'vegas.chals.nitectf25.live'
PORT = 1337
USERNAME = "w4st3d"
# For this challenge, 32 works; 
# adjust only if the handout or observation indicates a different secret size(it depends on the challenge).
SECRET_LENGTH = 32

"""
    Read from the TLS-wrapped socket until 'pattern' is observed or timeout occurs.
    Args:
        sock: SSL socket-like object with .recv()
        pattern: bytes sequence to wait for (must be present in the stream)
        timeout: overall socket timeout (seconds)
    Returns:
        bytes buffer containing the data read (may be partial if timeout occurs)
"""
def recv_until(sock, pattern, timeout=10):
    data = b''
    sock.settimeout(timeout)
    try:
        while pattern not in data:
            chunk = sock.recv(4096)
            if not chunk:
                break
            data += chunk
    except Exception:
        # Silent fail: caller will decide based on partial data.
        pass
    return data


"""
    Send a line terminated by newline to the server.
    Args:
        sock: SSL socket-like object with .sendall()
        line: str or bytes; will be ASCII/UTF-8 encoded if str
    Protocol:
        - The challenge expects newline-terminated commands.
"""
def send_line(sock, line):
    if isinstance(line, str):
        line = line.encode()
    sock.sendall(line + b'\n')


attempt = 0
print("[*] Starting fast exploit...")
print(f"[*] Target: {HOST}:{PORT}")
print(f"[*] Will report every 10 attempts\n")

# Outer loop: reconnect per attempt to keep state clean 
# and avoid server-side rate limits which have occured a lot
while True:
    attempt += 1
    try:
        # Create a default TLS context and connect.
        context = ssl.create_default_context()
        with socket.create_connection((HOST, PORT), timeout=15) as sock:
            with context.wrap_socket(sock, server_hostname=HOST) as ssock:

                # Log in / provide username
                recv_until(ssock, b'Enter your username: ')
                send_line(ssock, USERNAME)
                recv_until(ssock, b'Enter your choice: ')

                # Inner loop: purchase up to 10 tickets per connection 
				# to amortize handshake overhead (one method of the two to raise money)
                for _ in range(10):
                    # Select the Lottery game (menu option '3'), then buy a ticket ('1').
                    send_line(ssock, '3')
                    recv_until(ssock, b'): ')
                    send_line(ssock, '1')

                    # Read response until a new 'choice'
                    response = recv_until(ssock, b'choice: ', timeout=5)

                    # If we won, the server prints voucher details
                    if b'You won!' in response:
                        # Extract voucher fields: hex-encoded data and code (20-byte hash // only in this challenge)
                        data_match = re.search(rb'Voucher data:\s+([0-9a-f]+)', response)
                        code_match = re.search(rb'Voucher code:\s+([0-9a-f]+)', response)

                        if data_match and code_match:
                            voucher_data = data_match.group(1).decode()
                            voucher_code = code_match.group(1).decode()

                            # Prepare original message bytes from hex; perform SHA-1 length extension(decode them for better results)
                            original_data = bytes.fromhex(voucher_data)

                            # Append '|1000000000' to override the amount based on server's rightmost-token parse.
                            new_hash, new_data = sha1_extend(
                                voucher_code,      # original SHA-1 digest (hex)
                                original_data,     # known message suffix: b"username|amount"
                                b'|1000000000',    # suffix to append
                                SECRET_LENGTH      # assumed secret length
                            )

                            # Redeem forged voucher: send new hash and extended data (hex) to the server.
                            send_line(ssock, '4')  # menu option: Redeem voucher
                            recv_until(ssock, b'code(hex): ')
                            send_line(ssock, new_hash)
                            recv_until(ssock, b'data(hex): ')
                            send_line(ssock, new_data.hex())

                            # Check redemption outcome; if not invalid, consider success and fetch flag.
                            response = recv_until(ssock, b'choice: ')

                            if b'Invalid voucher' not in response:
                                print(f"\n[+] SUCCESS on attempt {attempt}!")
                                print(f"[+] Voucher code: {voucher_code}")
                                print(f"[+] Extended hash: {new_hash}")
                                print(response.decode())

                                # Request the flag (menu option '6'), then print lines received.
                                send_line(ssock, '6')
                                flag_response = recv_until(ssock, b'\n')
                                print(flag_response.decode())

                                try:
                                    more = recv_until(ssock, b'\n', timeout=2)
                                    print(more.decode())
                                except Exception:
                                    pass

                                # Cleanly exit after success.
                                sys.exit(0)
                        # If win but vouchers not found or extension fails, break and try next cycle.
                        break

                # Periodic status to keep operator informed without spamming output.
                if attempt % 5 == 0:
                    print(f"[*] Attempt {attempt}...", flush=True)

    except Exception as e:
        # Suppress frequent network/transient errors; report occasionally for situational awareness.
        if attempt % 10 == 0:
            print(f"[!] Error on attempt {attempt}: {e}", flush=True)
        continue
